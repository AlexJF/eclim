<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright (c) 2005 - 2006

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN"
  "http://forrest.apache.org/dtd/document-v20.dtd">
<!--
 Author: Eric Van Dewoestine
-->

<document>
  <header>
    <title>Searching code in vim</title>
    <authors>
      <person name="Eric Van Dewoestine" email="ervandew@yahoo.com"/>
    </authors>
  </header>
  <body>
    <section id="pattern">
      <title>Pattern Search</title>
      <p>
        Pattern searching provides a means to widen a search beyond a single
        element.  A pattern search can be executed using the command<br/>
        &nbsp;&nbsp;<strong>:JavaSearch</strong> -p &lt;pattern&gt; -t &lt;type&gt; -x
        &lt;context&gt; -s &lt;scope&gt;
      </p>
      <p>
        All of the results will be placed into vim's quickfix window so that you
        can easily navigate the results.
      </p>
      <note>
        Vim command completion is supported through out the command with the
        excption of the pattern to search for.<br/>
        <code>:JavaSearch &lt;Tab&gt;</code><br/>
        <code>:JavaSearch -p MyClass* &lt;Tab&gt;</code><br/>
        <code>:JavaSearch -p MyClass* -t &lt;Tab&gt;</code><br/>
        <code>:JavaSearch -p MyClass* -t all &lt;Tab&gt;</code><br/>
        <code>:JavaSearch -p MyClass* -t all -x &lt;Tab&gt;</code><br/>
        <code>:JavaSearch -p MyClass* -t all -x declarations</code>
      </note>
      <ul>
        <li>
          pattern: The pattern to search for.<br/>
          Ex.<br/>
          &nbsp;&nbsp;MyClass*<br/>
          &nbsp;&nbsp;MyClass.someMethod*
        </li>
        <li>
          type: The type of element to search for where possible types include
          <ul>
            <li>annotation</li>
            <li>class</li>
            <li>classOrEnum</li>
            <li>classOrInterface</li>
            <li>constructor</li>
            <li>enum</li>
            <li>field</li>
            <li>interface</li>
            <li>method</li>
            <li>package</li>
            <li>type</li>
          </ul>
        </li>
        <li>
          context: The context to search under where possible context values
          include
          <ul>
            <li>all - All occurances.</li>
            <li>declarations - Declarations matching the pattern or element.</li>
            <li>implementors - Implementors of the pattern or element.</li>
            <li>references - References of the pattern or element.</li>
          </ul>
        </li>
        <li>
          scope: The scope of the search where possible context values include
          <ul>
            <li>all - Search the whole workspace.</li>
            <li>
              project - Search the current project, dependent projects, and
              libraries.
            </li>
            <li>type - Search only in the current type (source file).</li>
          </ul>
        </li>
      </ul>
    </section>
    <section id="element">
      <title>Element Search</title>
      <p>
        Element searching allows you to place the cursor over just about any
        element in a source file (method call, class name, field) and perform a
        search for that element.  Performing an element search is the same as
        performing a pattern search with the exception that you do not specify
        the -p option since the element under the cursor will be searched for
        instead.
      </p>
      <p>
        If only one result is found and that result is in the current source
        file, the cursor will be moved to that element found.
      </p>
    </section>
    <section id="alternate">
      <title>Alternate Searching</title>
      <p>
        For those occasions that you find yourself browsing a third party source
        distribution that you want to be able to search without going through the
        steps of setting up a project, eclim provides an alternate searching
        mechanism. To utilize the alternate searching requires no change in
        behavior or commands, but to achieve the best results, you should know
        how it works.
      </p>
      <p>
        The first thing worth noting is that the alternate search is currently a
        bit limited.  It only supports searches involving types (classes,
        interfaces, annotations, and enums).  It doesn't currently have any
        support for methods or fields.
      </p>
      <p>
        Secondly, it can only search for and locate types within the current
        source tree.  Searching across the jdk source or other third party
        source files without setting up an eclipse or similar classpath, is
        difficult at worst, and slow at best.
      </p>
      <p>
        With that said, I've found that when I'm walking through a third party
        source tree, my main focus is on finding referenced classes / interfaces
        quickly and easily, and the eclim alternate searching does just that.
      </p>
      <p>
        Invoking the search is the same as the standard search mechanism.  You
        simply use the same <strong>:JavaSearch</strong> command as you normally
        would.  The only difference is that the alternate search doesn't support
        the -t option and will notify you of such if supplied.
      </p>
      <p>
        When invoked the alternate search eclim will attempt its search as
        follows:
      </p>
      <ul>
        <li>
          It will grab the full path of the current source file, strip off the
          package and search from the resulting directory.<br/>
          Ex.  When editing a file /usr/local/java/foo/src/org/foo/bar/Baz.java,
          <br/>the alternate search will first search the directory
          /usr/local/java/foo/src.
        </li>
        <li>
          If no files are found in that directory, then it will proceed to
          search vim's 'path' option (:h 'path' for more info on this option).
          <br/>As an example, I have my 'path' set to '/usr/local/java/java-src'
          and in that directory is where I store all my third party source
          distributions (hibernate, spring, axis, etc.).
        </li>
        <li>
          Once one or more files are found, the search will stop if the
          requested search was for declarations.  For all searches, eclim will
          first try to find the declarations and if the user requested a search
          for implementors, references, or all, then the eclim will proceed to
          the next step.
        </li>
        <li>
          For non-declaration searches, if multiple declaring source files are
          found, eclim will prompt you to narrow the results down to the type
          you would like results for.
        </li>
        <li>
          Once eclim has narrowed the search down to the specific type to
          proceed with, it will then attempt to narrow the search down to a
          specific source distribution directory.  To do this it locates
          the relevant entry from the 'path' option, tacks on one more level
          of the path from the resulting file, and commences its search from
          there.<br/>
          Ex.  When searching for all implementors of MyType, if eclim finds
          a file /usr/local/java/java-src/myproject/core/src/org/my/MyType.java
          and a 'path' entry of /usr/local/java/java-src exists, then eclim
          will deduce that that search must continue in the directory
          /usr/local/java/java-src/myproject.
        </li>
      </ul>
      <p>
        This may seem a bit complicated for a simple search, but in practice
        it's actually quite simple, and as usual, I'm open to any and all
        comments and suggestions.
      </p>
      <note>
        Alternate searching is bound to the performance of the file system and
        as such, the response time on Windows can be significantly slower than
        Linux.  The biggest impact is when searching for 'implementors',
        'references', and 'all'.  The number of and depth of the directories in
        your vim 'path' option can also impact performance.
      </note>
    </section>
    <section id="configuration">
      <title>Configuration</title>
      <p>
        Vim Variables:
      </p>
      <ul>
        <li>
          <strong>g:EclimJavaSearchSingleResult</strong><br/>
          Determines what action to take when a only a single result is
          found.<br/>
          Possible values include:
          <ul>
            <li>'split' - open the result in a new window via "split".</li>
            <li>'edit' - open the result in the current window.</li>
            <li>'copen' - open the quickfix window to display the result.</li>
          </ul>
        </li>
        <li>
          <strong>g:EclimJavaSearchMapping</strong><br/>
          When set to 1, &lt;Enter&gt; will be mapped to the java search
          functionality for the various java related xml files (spring,
          hibernate, web.xml, and struts-config.xml).  By default this is
          enabled.
        </li>
      </ul>
    </section>
  </body>
</document>
